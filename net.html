<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8">
    <title>Responsive Fabric</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: sans-serif;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Контент поверх тканини */
        .ui {
            text-align: center;
            margin-top: 30vh;
            position: relative;
            z-index: 2;
            pointer-events: none;
            /* Пропускає кліки на тканину */
            color: white;
            padding: 50px;
        }

        .ui button {
            pointer-events: auto;
            /* Робить кнопку клікабельною */
            margin-top: 10px;
            padding: 10px 40px;
            cursor: pointer;
        }

        .p {
            word-spacing: 20px;
        }
    </style>
</head>

<body>

    <div class="ui">
        <h1>______elija______</h1>
        <p class="p">no longer quiet</p>
        <button><a href="https://elija.bandcamp.com">___wav___</a></button>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let points = [];
        let constraints = [];
        let mouse = { x: 0, y: 0, oldX: 0, oldY: 0 };

        const settings = {
            gravity: 0.25,
            friction: 0.82,
            spacing: 13,      // Відстань між точками
            tearDistance: 115, // Міцність
            stiffness: 1,
            mouseRadius: 30,
            mouseStrength: 0.6
        };

        // Розраховуємо кількість стовпців та рядів залежно від екрана
        let cols, rows;

        class Point {
            constructor(x, y, pinned = false) {
                this.x = x; this.y = y;
                this.oldX = x; this.oldY = y;
                this.pinned = pinned;
            }
            update() {
                if (this.pinned) return;
                let vx = (this.x - this.oldX) * settings.friction;
                let vy = (this.y - this.oldY) * settings.friction;
                this.oldX = this.x; this.oldY = this.y;
                this.x += vx; this.y += vy + settings.gravity;

                let dx = this.x - mouse.x;
                let dy = this.y - mouse.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < settings.mouseRadius) {
                    this.x += (mouse.x - mouse.oldX) * settings.mouseStrength;
                    this.y += (mouse.y - mouse.oldY) * settings.mouseStrength;
                }
            }
        }

        class Constraint {
            constructor(p1, p2) {
                this.p1 = p1; this.p2 = p2;
                this.length = settings.spacing;
                this.active = true;
            }
            update() {
                if (!this.active) return;
                let dx = this.p2.x - this.p1.x;
                let dy = this.p2.y - this.p1.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > settings.tearDistance) { this.active = false; return; }
                let diff = (this.length - dist) / dist * settings.stiffness;
                let ox = dx * diff * 0.5;
                let oy = dy * diff * 0.5;
                if (!this.p1.pinned) { this.p1.x -= ox; this.p1.y -= oy; }
                if (!this.p2.pinned) { this.p2.x += ox; this.p2.y += oy; }
            }
        }

        function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Динамічний розрахунок сітки
            cols = Math.floor(canvas.width / settings.spacing);
            rows = Math.floor(canvas.height / settings.spacing * 0.65); // 60% висоти екрана

            points = [];
            constraints = [];

            for (let y = 0; y <= rows; y++) {
                for (let x = 0; x <= cols; x++) {
                    let p = new Point(x * settings.spacing, y * settings.spacing, y === 0);
                    points.push(p);
                    if (x > 0) constraints.push(new Constraint(points[points.length - 2], p));
                    if (y > 0) constraints.push(new Constraint(points[points.length - (cols + 2)], p));
                }
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < 2; i++) {
                constraints.forEach(c => c.update());
                points.forEach(p => p.update());
            }
            ctx.beginPath();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
            constraints.forEach(c => {
                if (c.active) {
                    ctx.moveTo(c.p1.x, c.p1.y);
                    ctx.lineTo(c.p2.x, c.p2.y);
                }
            });
            ctx.stroke();
            mouse.oldX = mouse.x;
            mouse.oldY = mouse.y;
            requestAnimationFrame(animate);
        }

        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        // Важливо: переініціалізація при зміні розміру вікна
        window.addEventListener('resize', init);

        init();
        animate();
    </script>
</body>

</html>